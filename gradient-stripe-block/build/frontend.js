!function(){"use strict";function e(e){const n=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return n?{r:parseInt(n[1],16)/255,g:parseInt(n[2],16)/255,b:parseInt(n[3],16)/255}:{r:0,g:0,b:0}}function n(e,n,o){const r=e.createShader(n);return e.shaderSource(r,o),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS)?r:(console.error("Shader compile error:",e.getShaderInfoLog(r)),e.deleteShader(r),null)}function o(o){const r=o.getContext("webgl")||o.getContext("experimental-webgl");if(!r)return void(o.style.background="linear-gradient(90deg, #1dcb5d, #ffe85e, #ffa832)");const t=e(o.dataset.color1||"#1dcb5d"),l=e(o.dataset.color2||"#ffe85e"),a=e(o.dataset.color3||"#ffa832"),i=e(o.dataset.color4||"#ffce48"),c=parseFloat(o.dataset.speed)||1,d=parseFloat(o.dataset.noiseScale)||1,b=parseFloat(o.dataset.turbulence)||.7,s=parseFloat(o.dataset.octaves)||3,u=parseFloat(o.dataset.lacunarity)||2,f=parseFloat(o.dataset.meshIntensity)||.3,m=parseFloat(o.dataset.colorBlendMode)||0,v=parseFloat(o.dataset.blendStrength)||1,g=n(r,r.VERTEX_SHADER,"\n        attribute vec2 a_position;\n        void main() {\n            gl_Position = vec4(a_position, 0.0, 1.0);\n        }\n    "),x=n(r,r.FRAGMENT_SHADER,"\n        precision highp float;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        uniform vec3 u_color1;\n        uniform vec3 u_color2;\n        uniform vec3 u_color3;\n        uniform vec3 u_color4;\n        uniform float u_noiseScale;\n        uniform float u_turbulence;\n        uniform float u_octaves;\n        uniform float u_lacunarity;\n        uniform float u_meshIntensity;\n        uniform float u_colorBlendMode;\n        uniform float u_blendStrength;\n\n        // Blend mode functions\n        vec3 blendMultiply(vec3 base, vec3 blend) { return base * blend; }\n        vec3 blendScreen(vec3 base, vec3 blend) { return 1.0 - (1.0 - base) * (1.0 - blend); }\n        vec3 blendOverlay(vec3 base, vec3 blend) {\n            return vec3(\n                base.r < 0.5 ? 2.0 * base.r * blend.r : 1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r),\n                base.g < 0.5 ? 2.0 * base.g * blend.g : 1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g),\n                base.b < 0.5 ? 2.0 * base.b * blend.b : 1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b)\n            );\n        }\n        vec3 blendSoftLight(vec3 base, vec3 blend) {\n            return vec3(\n                blend.r < 0.5 ? base.r - (1.0 - 2.0 * blend.r) * base.r * (1.0 - base.r) : base.r + (2.0 * blend.r - 1.0) * (sqrt(base.r) - base.r),\n                blend.g < 0.5 ? base.g - (1.0 - 2.0 * blend.g) * base.g * (1.0 - base.g) : base.g + (2.0 * blend.g - 1.0) * (sqrt(base.g) - base.g),\n                blend.b < 0.5 ? base.b - (1.0 - 2.0 * blend.b) * base.b * (1.0 - base.b) : base.b + (2.0 * blend.b - 1.0) * (sqrt(base.b) - base.b)\n            );\n        }\n        vec3 blendHardLight(vec3 base, vec3 blend) { return blendOverlay(blend, base); }\n        vec3 blendColorDodge(vec3 base, vec3 blend) {\n            return vec3(\n                blend.r >= 1.0 ? 1.0 : min(1.0, base.r / (1.0 - blend.r)),\n                blend.g >= 1.0 ? 1.0 : min(1.0, base.g / (1.0 - blend.g)),\n                blend.b >= 1.0 ? 1.0 : min(1.0, base.b / (1.0 - blend.b))\n            );\n        }\n        vec3 blendColorBurn(vec3 base, vec3 blend) {\n            return vec3(\n                blend.r <= 0.0 ? 0.0 : max(0.0, 1.0 - (1.0 - base.r) / blend.r),\n                blend.g <= 0.0 ? 0.0 : max(0.0, 1.0 - (1.0 - base.g) / blend.g),\n                blend.b <= 0.0 ? 0.0 : max(0.0, 1.0 - (1.0 - base.b) / blend.b)\n            );\n        }\n        vec3 applyBlendMode(vec3 base, vec3 blend, float mode) {\n            vec3 result;\n            if (mode < 0.5) result = mix(base, blend, 0.5);\n            else if (mode < 1.5) result = blendMultiply(base, blend);\n            else if (mode < 2.5) result = blendScreen(base, blend);\n            else if (mode < 3.5) result = blendOverlay(base, blend);\n            else if (mode < 4.5) result = blendSoftLight(base, blend);\n            else if (mode < 5.5) result = blendHardLight(base, blend);\n            else if (mode < 6.5) result = blendColorDodge(base, blend);\n            else result = blendColorBurn(base, blend);\n            return result;\n        }\n\n        // Simplex noise functions\n        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n        float snoise(vec2 v) {\n            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n            vec2 i = floor(v + dot(v, C.yy));\n            vec2 x0 = v - i + dot(i, C.xx);\n            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n            vec4 x12 = x0.xyxy + C.xxzz;\n            x12.xy -= i1;\n            i = mod289(i);\n            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n            m = m*m;\n            m = m*m;\n            vec3 x = 2.0 * fract(p * C.www) - 1.0;\n            vec3 h = abs(x) - 0.5;\n            vec3 ox = floor(x + 0.5);\n            vec3 a0 = x - ox;\n            m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n            vec3 g;\n            g.x = a0.x * x0.x + h.x * x0.y;\n            g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n            return 130.0 * dot(m, g);\n        }\n\n        // Fractal Brownian Motion\n        float fbm(vec2 p, float time) {\n            float value = 0.0;\n            float amplitude = 0.5;\n            float frequency = 1.0;\n            float timeScale = 0.0004;\n            for (int i = 0; i < 5; i++) {\n                if (float(i) >= u_octaves) break;\n                value += amplitude * snoise(p * frequency + vec2(time * timeScale * (0.5 + float(i) * 0.2), time * timeScale * (0.3 - float(i) * 0.1)));\n                amplitude *= u_turbulence;\n                frequency *= u_lacunarity;\n            }\n            return value;\n        }\n\n        void main() {\n            vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n            vec2 pos = gl_FragCoord.xy;\n            float scale = 0.0015 / u_noiseScale;\n            float combinedNoise = fbm(pos * scale, u_time);\n            vec2 meshFreq = vec2(3.0, 2.0);\n            float meshNoise = sin(uv.x * meshFreq.x + u_time * 0.001) * cos(uv.y * meshFreq.y - u_time * 0.0008);\n            combinedNoise = combinedNoise * (1.0 - u_meshIntensity) + meshNoise * u_meshIntensity;\n            float t = (combinedNoise + 1.0) * 0.5;\n            t = smoothstep(0.0, 1.0, t);\n            \n            vec3 finalColor;\n            vec3 blendedColor;\n            float mixFactor;\n            \n            if (t < 0.33) {\n                mixFactor = smoothstep(0.0, 0.33, t) * 3.0;\n                blendedColor = applyBlendMode(u_color1, u_color2, u_colorBlendMode);\n                finalColor = mix(u_color1, mix(u_color2, blendedColor, u_blendStrength), mixFactor);\n            } else if (t < 0.66) {\n                mixFactor = (t - 0.33) / 0.33;\n                blendedColor = applyBlendMode(u_color2, u_color3, u_colorBlendMode);\n                finalColor = mix(u_color2, mix(u_color3, blendedColor, u_blendStrength), mixFactor);\n            } else {\n                mixFactor = (t - 0.66) / 0.34;\n                blendedColor = applyBlendMode(u_color3, u_color4, u_colorBlendMode);\n                finalColor = mix(u_color3, mix(u_color4, blendedColor, u_blendStrength), mixFactor);\n            }\n            \n            gl_FragColor = vec4(finalColor, 1.0);\n        }\n    "),_=function(e,n,o){const r=e.createProgram();return e.attachShader(r,n),e.attachShader(r,o),e.linkProgram(r),e.getProgramParameter(r,e.LINK_STATUS)?r:(console.error("Program link error:",e.getProgramInfoLog(r)),e.deleteProgram(r),null)}(r,g,x),h=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,h),r.bufferData(r.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),r.STATIC_DRAW);const p=r.getAttribLocation(_,"a_position"),y=r.getUniformLocation(_,"u_resolution"),S=r.getUniformLocation(_,"u_time"),F=r.getUniformLocation(_,"u_color1"),C=r.getUniformLocation(_,"u_color2"),L=r.getUniformLocation(_,"u_color3"),A=r.getUniformLocation(_,"u_color4"),B=r.getUniformLocation(_,"u_noiseScale"),R=r.getUniformLocation(_,"u_turbulence"),U=r.getUniformLocation(_,"u_octaves"),w=r.getUniformLocation(_,"u_lacunarity"),I=r.getUniformLocation(_,"u_meshIntensity"),M=r.getUniformLocation(_,"u_colorBlendMode"),E=r.getUniformLocation(_,"u_blendStrength");let P=0;const T=o.parentElement;function q(){const e=T.getBoundingClientRect();o.width=e.width,o.height=e.height,r.viewport(0,0,o.width,o.height)}q(),window.addEventListener("resize",q),function e(){P+=c,r.clearColor(1,1,1,1),r.clear(r.COLOR_BUFFER_BIT),r.useProgram(_),r.uniform2f(y,o.width,o.height),r.uniform1f(S,P),r.uniform3f(F,t.r,t.g,t.b),r.uniform3f(C,l.r,l.g,l.b),r.uniform3f(L,a.r,a.g,a.b),r.uniform3f(A,i.r,i.g,i.b),r.uniform1f(B,d),r.uniform1f(R,b),r.uniform1f(U,s),r.uniform1f(w,u),r.uniform1f(I,f),r.uniform1f(M,m),r.uniform1f(E,v),r.enableVertexAttribArray(p),r.bindBuffer(r.ARRAY_BUFFER,h),r.vertexAttribPointer(p,2,r.FLOAT,!1,0,0),r.drawArrays(r.TRIANGLE_STRIP,0,4),requestAnimationFrame(e)}()}document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll(".gsb-gradient-canvas").forEach(o)})}();